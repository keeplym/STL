1.最大载入因子
一个给定的哈希值会选择特定的格子，因为哈希值可能的个数几乎可以肯定会大于格子的个数，两个不同的哈希值可能会映射到同一个格子上。
因此，不同键会产生相同的哈希值，会产生碰撞，而且两个不同的哈希值选择相同的格子也会导致碰撞的产生。

下面的一些参数可以影响元素存储的管理：
（1）容器中格子的个数有一个默认值，但也可以定指定初始个数。
（2）载入因子是每个格子平均保存的元素的个数。这个值等于容器中元素个数除以格子的个数。

最大载入因子，默认是 1.0，但也可以修改。这是载入因子的上限。当容器达到最大载入因子时，容器会为格子分配更多的空间，这通常也会对容器中的元素重新进行哈希。

任何时候都不要将单个格子中的最大元素个数和最大载入因子混淆。假设有一个容器，它有 8 个格子，前两个格子中各有 3 个元素，剩下的格子都为空。
那么这时候的最大载入因子为 6/8，也就是 0.75，小于默认的最大载入因子 1.0，所以这没有什么问题。

2.调整格子个数
在维持当前载入因子的前提下，如果插入元素数超过了格子可以满足的个数，容器将不得不增加格子的个数。
那么为了将元素重新分配到新的格子中，元素会被再次哈希。这时，这个容器当前存在的任何迭代器都会失效。
在任何时候都可以调用成员函数 rehash() 来改变格子的个数：
	people.rehash(15); // Make bucket count 15
rehash() 的参数可以比当前格子数多或少。这条语句会将格子的个数变为 15，只要它不导致当前因子超过最大载入因子。
容器中的所有元素都会被重新哈希分配到新的格子中，而且当前所有的迭代器都会失效。如果指定的格子个数导致载入因子超过最大载入因子，那么格子会自动增加来避免超出最大值。

如果确定会增加格子的个数，可以使用 bucket_count() 返回的值：
	people.rehash((5*people.bucket_count())/4); // Increase bucket count by 25%
另一种方式是增加最大载入因子，也就是增加每个格子所包含的元素个数：
	people.max_load_factor(1.2*people.max_load_factor()); // 工ncrease max load factor by 20%
为了改变最大载入因子，可以以新的最大载入因子为参数调用容器的 max_load_factor(); 
如果无参数地调用这个函数，它会返回当前的最大载入因子，可以用它来设置新的值。

可以发现，调用 unordered_map 的成员函数 load_factor() 时返回的当前载入因子是一个浮点值：
	float lf = people.load_factor();
也可以选择设置格子的个数，使它们在容纳给定个数的元素的同时将负载因子维持在最大数之内：
	size_t max_element_count {100};
	people.reserve(max_element_count);
这里设置了格子的个数，使它可以容纳 100 个元素而不超过最大载入因子的限制。这会导致容器中的内容被重新哈希，从而使所有的当前迭代器失效。
当然，也可以不考虑载入因子和格子个数来生成和使用 unordered_map 容器。容器自己会处理这些事情。